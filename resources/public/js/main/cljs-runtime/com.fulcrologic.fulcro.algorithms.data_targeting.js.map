{"version":3,"sources":["com/fulcrologic/fulcro/algorithms/data_targeting.cljc"],"mappings":"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","names":["cljs.spec.alpha/def-impl","cljs.core/vector?","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","com.fulcrologic.fulcro.algorithms.data-targeting/multiple-targets","seq61834","self__4718__auto__","cljs.core/seq","targets","cljs.core/with-meta","cljs.core/vec","com.fulcrologic.fulcro.algorithms.data-targeting/prepend-to","target","com.fulcrologic.fulcro.algorithms.data-targeting/append-to","com.fulcrologic.fulcro.algorithms.data-targeting/replace-at","com.fulcrologic.fulcro.algorithms.data-targeting/replacement-target?","t","cljs.core/meta","cljs.core/boolean","com.fulcrologic.fulcro.algorithms.data-targeting/prepend-target?","com.fulcrologic.fulcro.algorithms.data-targeting/append-target?","com.fulcrologic.fulcro.algorithms.data-targeting/multiple-targets?","com.fulcrologic.fulcro.algorithms.data-targeting/special-target?","clojure.set.intersection.cljs$core$IFn$_invoke$arity$2","cljs.core/keys","cljs.core/set","com.fulcrologic.fulcro.algorithms.data-targeting/integrate-ident*","seq61842","G__61843","cljs.core/first","cljs.core/next","G__61844","self__4717__auto__","state","ident","named-parameters","actions","cljs.core.partition.cljs$core$IFn$_invoke$arity$2","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","p__61845","vec__61846","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","command","data-path","already-has-ident-at-path?","p1__61840#","cljs.core/some","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","G__61849","cljs.core/Keyword","p1__61841#","cljs.core.update_in.cljs$core$IFn$_invoke$arity$3","cljs.core.into.cljs$core$IFn$_invoke$arity$2","cljs.core.update_in.cljs$core$IFn$_invoke$arity$4","cljs.core.fnil.cljs$core$IFn$_invoke$arity$2","cljs.core/conj","path-to-vector","cljs.core/butlast","to-many?","index","cljs.core/last","vector","taoensso.timbre._log_BANG_.cljs$core$IFn$_invoke$arity$10","taoensso.timbre/*config*","cljs.core/Delay","cljs.core/contains?","cljs.core/assoc-in","G__61852","com.fulcrologic.fulcro.algorithms.data-targeting/process-target","js/Error","state-map","source-path","com.fulcrologic.fulcro.algorithms.data_targeting.process_target.cljs$core$IFn$_invoke$arity$4","remove-source?","item-to-place","edn-query-language.core/ident?","cljs.core.get.cljs$core$IFn$_invoke$arity$2","many-idents?","cljs.core/every?","G__61853","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","G__61854","s","and__4120__auto__","target-has-many?","v","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","G__61855","com.fulcrologic.fulcro.algorithms.data_targeting.integrate_ident_STAR_.cljs$core$IFn$_invoke$arity$variadic"],"sourcesContent":["(ns com.fulcrologic.fulcro.algorithms.data-targeting\n  \"The implementation of processing load/mutation result graph targeting.\"\n  (:require\n    [clojure.spec.alpha :as s]\n    [clojure.set :as set]\n    [ghostwheel.core :as gw :refer [>defn =>]]\n    [taoensso.timbre :as log]\n    [edn-query-language.core :as eql]))\n\n(s/def ::target vector?)\n\n(>defn multiple-targets\n  \"Specifies a target that should place edges in the graph at multiple locations.\n\n  `targets` - Any number of targets.  A target can be a simple path (as a vector), or other\n  special targets like `append-to` and `prepend-to`.\"\n  [& targets]\n  [(s/* ::target) => ::target]\n  (with-meta (vec targets) {::multiple-targets true}))\n\n(>defn prepend-to\n  \"Specifies a to-many target that will preprend an edge to some to-many edge. NOTE: this kind of target will not\n  create duplicates in the target list.\n\n  `target` - A vector (path) in the normalized database of the to-many list of idents.\n  \"\n  [target]\n  [::target => ::target]\n  (with-meta target {::prepend-target true}))\n\n(>defn append-to\n  \"Specifies a to-many target that will append an edge to some to-many edge. NOTE: this kind of target will not\n  create duplicates in the target list.\n\n  `target` - A vector (path) in the normalized database of the to-many list of idents.\"\n  [target]\n  [::target => ::target]\n  (with-meta target {::append-target true}))\n\n(>defn replace-at\n  \"Specifies a target that will replace an edge at some normalized location.\n\n  `target` - A vector (path) in the normalized database. This path can include numbers to target some element\n  of an existing to-many list of idents.\"\n  [target]\n  [::target => ::target]\n  (with-meta target {::replace-target true}))\n\n(>defn replacement-target? [t] [any? => boolean?] (-> t meta ::replace-target boolean))\n(>defn prepend-target? [t] [any? => boolean?] (-> t meta ::prepend-target boolean))\n(>defn append-target? [t] [any? => boolean?] (-> t meta ::append-target boolean))\n(>defn multiple-targets? [t] [any? => boolean?] (-> t meta ::multiple-targets boolean))\n\n(>defn special-target?\n  \"Is the given target special? This means it is not just a plain vector path, but is instead something like\n  an append.\"\n  [target]\n  [any? => boolean?]\n  (boolean (seq (set/intersection (-> target meta keys set) #{::replace-target ::append-target ::prepend-target ::multiple-targets}))))\n\n(>defn integrate-ident*\n  \"Integrate an ident into any number of places in the app state. This function is safe to use within mutation\n  implementations as a general helper function.\n\n  The named parameters can be specified any number of times. They are:\n\n  - append:  A vector (path) to a list in your app state where this new object's ident should be appended. Will not append\n  the ident if that ident is already in the list.\n  - prepend: A vector (path) to a list in your app state where this new object's ident should be prepended. Will not place\n  the ident if that ident is already in the list.\n  - replace: A vector (path) to a specific location in app-state where this object's ident should be placed. Can target a to-one or to-many.\n   If the target is a vector element then that element must already exist in the vector.\n\n  NOTE: `ident` does not have to be an ident if you want to place denormalized data.  It can really be anything.\n\n  Returns the updated state map.\"\n  [state ident & named-parameters]\n  [map? any? (s/* (s/or :path ::target :command #{:append :prepend :replace})) => map?]\n  (let [actions (partition 2 named-parameters)]\n    (reduce (fn [state [command data-path]]\n              (let [already-has-ident-at-path? (fn [data-path] (some #(= % ident) (get-in state data-path)))]\n                (case command\n                  :prepend (if (already-has-ident-at-path? data-path)\n                             state\n                             (update-in state data-path #(into [ident] %)))\n                  :append (if (already-has-ident-at-path? data-path)\n                            state\n                            (update-in state data-path (fnil conj []) ident))\n                  :replace (let [path-to-vector (butlast data-path)\n                                 to-many?       (and (seq path-to-vector) (vector? (get-in state path-to-vector)))\n                                 index          (last data-path)\n                                 vector         (get-in state path-to-vector)]\n                             (when-not (vector? data-path) (log/error \"Replacement path must be a vector. You passed: \" data-path))\n                             (when to-many?\n                               (cond\n                                 (not (vector? vector)) (log/error \"Path for replacement must be a vector\")\n                                 (not (number? index)) (log/error \"Path for replacement must end in a vector index\")\n                                 (not (contains? vector index)) (log/error \"Target vector for replacement does not have an item at index \" index)))\n                             (assoc-in state data-path ident))\n                  state)))\n      state actions)))\n\n(>defn process-target\n  \"Process a load target (which can be a multiple-target).\n\n  `state-map` - the state-map\n  `source-path` - A keyword, ident, or app-state path.  If the source path is an ident, then that is what is placed\n     in app state.  If it is a keyword or longer path then the thing at that location in app state is pulled from app state\n     and copied to the target location(s).\n  `target` - The target(s)\n  `remove-source?` - When true the source will be removed from app state once it has been written to the new location.\n\n  Returns an updated state-map with the given changes.\"\n  ([state-map source-path target]\n   [map? (s/or :key keyword? :ident eql/ident? :path vector?) ::target => map?]\n   (process-target state-map source-path target true))\n  ([state-map source-path target remove-source?]\n   [map? (s/or :key keyword? :ident eql/ident? :path vector?) ::target boolean? => map?]\n   (let [item-to-place (cond (eql/ident? source-path) source-path\n                             (keyword? source-path) (get state-map source-path)\n                             :else (get-in state-map source-path))\n         many-idents?  (and (vector? item-to-place)\n                         (every? eql/ident? item-to-place))]\n     (cond\n       (and (eql/ident? source-path)\n         (not (special-target? target))) (-> state-map\n                                           (assoc-in target item-to-place))\n       (not (special-target? target)) (cond->\n                                        (assoc-in state-map target item-to-place)\n                                        remove-source? (dissoc source-path))\n       (multiple-targets? target) (cond-> (reduce (fn [s t] (process-target s source-path t false)) state-map target)\n                                    (and (not (eql/ident? source-path)) remove-source?) (dissoc source-path))\n       (and many-idents? (special-target? target)) (let [state            (if remove-source?\n                                                                            (dissoc state-map source-path)\n                                                                            state-map)\n                                                         target-has-many? (vector? (get-in state target))]\n                                                     (if target-has-many?\n                                                       (cond\n                                                         (prepend-target? target) (update-in state target (fn [v] (vec (concat item-to-place v))))\n                                                         (append-target? target) (update-in state target (fn [v] (vec (concat v item-to-place))))\n                                                         :else state)\n                                                       (assoc-in state target item-to-place)))\n       (special-target? target) (cond-> state-map\n                                  remove-source? (dissoc source-path)\n                                  (prepend-target? target) (integrate-ident* item-to-place :prepend target)\n                                  (append-target? target) (integrate-ident* item-to-place :append target)\n                                  (replacement-target? target) (integrate-ident* item-to-place :replace target))\n       :else state-map))))\n"]}