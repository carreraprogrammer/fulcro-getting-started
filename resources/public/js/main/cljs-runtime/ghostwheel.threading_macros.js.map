{"version":3,"sources":["ghostwheel/threading_macros.cljc"],"mappings":";;;;AAmBA,AAAA,AAAA,AAAAA,AAAMM;AAAN,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAAG,AAAMD,AACHU,AAAeC;AADlB,AAAA,AAAAT,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAC0BU;AAD1B,AAEE,AAAA,AAAA,AAACC,AAAQ,AAAA,AAAKH,AAAmBC,AAAK,AAAA,AAAA,AAAA,AAAMC,AAAUA,AAC7B,AAAA,AAAQE;;;AAHnC,AAAA,AAAA,AAAMd;;AAAN;AAAA,AAAA,AAAA,AAAAI,AAAMJ;AAAN,AAAA,AAAAK,AAAA,AAAAC,AAAAF;AAAAA,AAAA,AAAAG,AAAAH;AAAAI,AAAA,AAAAF,AAAAF;AAAAA,AAAA,AAAAG,AAAAH;AAAA,AAAA,AAAAK,AAAA;AAAA,AAAA,AAAAA,AAAAJ,AAAAG,AAAAJ;;;AAAA,AAkFA,AAAA,AAAA,AAAAV,AAAOqB;AAAP,AAAA,AAAApB,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAoB,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAjB;;;AAAA,AAAA,AAAA,AAAA,AAAAkB,AAAOD,AACJW,AAAKC,AAAKC;AADb,AAAA,AAAAX,AAAAD;AAAA,AAAAb,AAAAc,AAAA,AAAA,AACqBY;AADrB,AAAA,AAAAX,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAGK,AAAA,AAAKK,AAEAC,AACLC,AACAC;;;AAPL,AAAA,AAAA,AAAOd;;AAAP;AAAA,AAAA,AAAA,AAAAO,AAAOP;AAAP,AAAA,AAAAQ,AAAA,AAAAjB,AAAAgB;AAAAA,AAAA,AAAAf,AAAAe;AAAAE,AAAA,AAAAlB,AAAAgB;AAAAA,AAAA,AAAAf,AAAAe;AAAAG,AAAA,AAAAnB,AAAAgB;AAAAA,AAAA,AAAAf,AAAAe;AAAA,AAAA,AAAAb,AAAA;AAAA,AAAA,AAAAA,AAAAc,AAAAC,AAAAC,AAAAH;;;AAAA,AA2DA,AAAA,AAAOQ,AACJC;AADH,AAAA,AAAAb,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAGK,AAEC,AAAA,AAAKU,AAAU,AAACC,AAAOC,AAAMC,AAAKA,AACnCH","names":["var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","ghostwheel.threading-macros/log-threading-header","p__58020","vec__58021","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","seq58014","G__58015","cljs.core/first","cljs.core/next","G__58016","self__4717__auto__","threading-type","expr","name","ghostwheel.logging.group.cljs$core$IFn$_invoke$arity$2","ghostwheel.logging/ghostwheel-colors","ghostwheel.threading-macros/log-cond-step","p__58033","vec__58034","cljs.core.sequence.cljs$core$IFn$_invoke$arity$1","cljs.core/seq","cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic","cljs.core/List","seq58028","G__58029","G__58030","G__58031","test","step","data","style","ghostwheel.threading-macros/log-some-step","some-step","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core/seq?","cljs.core/last"],"sourcesContent":[";; Copyright (c) George Lipov. All rights reserved.\n;; The use and distribution terms for this software are covered by the\n;; Eclipse Public License 2.0 (https://choosealicense.com/licenses/epl-2.0/)\n;; which can be found in the file LICENSE at the root of this distribution.\n;; By using this software in any fashion, you are agreeing to be bound by\n;; the terms of this license.\n;; You must not remove this notice, or any other, from this software.\n\n(ns ghostwheel.threading-macros\n  #?(:cljs (:require-macros ghostwheel.threading-macros))\n  (:require [ghostwheel.logging :as l :refer [ghostwheel-colors pr-clog]]\n            [ghostwheel.utils :as u :refer [cljs-env? clj->cljs]]))\n\n\n;;;; Traced threading macros\n\n\n;; REVIEW: Consider doing this at compile time and passing the &env to differentiate\n;; between Clojure and -Script\n(defn log-threading-header\n  [threading-type expr & [name]]\n  (l/group (str threading-type \" \" expr (when name \" \") name)\n           {::l/background (:black ghostwheel-colors)}))\n\n(defmacro *->\n  \"Traced version of ->\"\n  [orig-x & orig-forms]\n  (let [untraced `(~'-> ~orig-x ~@orig-forms)]\n    (cond->\n     (if-not (u/get-env-config)\n       untraced\n       `(if-not ghostwheel.core/*global-trace-allowed?*\n          ~untraced\n          ~(loop [x orig-x, forms orig-forms]\n             (if forms\n               (let [form     (first forms)\n                     threaded (if (seq? form)\n                                (with-meta `(pr-clog ~(str form)\n                                                     (~(first form) ~x ~@(next form)))\n                                           (meta form))\n                                `(pr-clog ~(str form)\n                                          ~(list form x)))]\n                 (recur threaded (next forms)))\n               `(do\n                  (log-threading-header \"->\" ~(str orig-x))\n                  (pr-clog ~(str orig-x) ~orig-x)\n                  (let [x# ~x]\n                    ~(when (cljs-env? &env)\n                       `(l/group-end))\n                    x#))))))\n     (cljs-env? &env) clj->cljs)))\n\n(defmacro *->>\n  \"Traced version of ->>\"\n  [orig-x & orig-forms]\n  (let [untraced `(~'->> ~orig-x ~@orig-forms)]\n    (cond->\n     (if-not (u/get-env-config)\n       untraced\n       `(if-not ghostwheel.core/*global-trace-allowed?*\n          ~untraced\n          (do\n            ~(loop [x orig-x, forms orig-forms]\n               (if forms\n                 (let [form     (first forms)\n                       threaded (if (seq? form)\n                                  (with-meta `(pr-clog ~(str form)\n                                                       (~(first form) ~@(next form) ~x))\n                                             (meta form))\n                                  `(pr-clog ~(str form)\n                                            ~(list form x)))]\n                   (recur threaded (next forms)))\n                 `(do\n                    (log-threading-header \"->>\" ~(str orig-x))\n                    (pr-clog ~(str orig-x) ~orig-x)\n                    (let [x# ~x]\n                      ~(when (cljs-env? &env)\n                         `(l/group-end))\n                      x#)))))))\n     (cljs-env? &env) clj->cljs)))\n\n(defmacro *as->\n  \"Traced version of as->\"\n  [expr name & forms]\n  (let [untraced `(~'as-> ~expr ~name ~@forms)\n        log-step (fn [form] `(pr-clog ~(str form) ~form))]\n    (cond->\n     (if-not (u/get-env-config)\n       untraced\n       `(if-not ghostwheel.core/*global-trace-allowed?*\n          ~untraced\n          (do\n            (log-threading-header \"as->\" ~(str expr) ~(str name))\n            (pr-clog ~(str name) ~expr)\n            (let [~name ~expr\n                  ~@(interleave (repeat name) (map log-step forms))]\n              ~(when (cljs-env? &env)\n                 `(l/group-end))\n              ~name))))\n     (cljs-env? &env) clj->cljs)))\n\n(defn- log-cond-step\n  [test step data & [style]]\n  `(pr-clog\n    ~(str test\n          \" \"\n          step)\n    ~data\n    ~style))\n\n(defmacro *cond->\n  \"Traced version of cond->\"\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [untraced `(~'cond-> ~expr ~@clauses)]\n    (cond->\n     (if-not (u/get-env-config)\n       untraced\n       `(if-not ghostwheel.core/*global-trace-allowed?*\n          ~untraced\n          ~(let [g     (gensym)\n                 pstep (fn [[test step]]\n                         `(if ~test\n                            ~(log-cond-step test step `(-> ~g ~step) {::l/weight :bold})\n                            ~(log-cond-step test step g {::l/foreground (:base0 ghostwheel-colors)})))]\n             `(do\n                (log-threading-header \"cond->\" ~(str expr))\n                (pr-clog ~(str expr) ~expr)\n                (let [~g ~expr\n                      ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n                  ~(when (cljs-env? &env)\n                     `(l/group-end))\n                  ~g)))))\n     (cljs-env? &env) clj->cljs)))\n\n(defmacro *cond->>\n  \"Traced version of cond->>\"\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [untraced `(~'cond->> ~expr ~@clauses)]\n    (cond->\n     (if-not (u/get-env-config)\n       untraced\n       `(if-not ghostwheel.core/*global-trace-allowed?*\n          ~untraced\n          ~(let [g     (gensym)\n                 pstep (fn [[test step]]\n                         `(if ~test\n                            ~(log-cond-step test step `(->> ~g ~step) {::l/weight :bold})\n                            ~(log-cond-step test step g {::l/foreground (:base0 ghostwheel-colors)})))]\n             `(do\n                (log-threading-header \"cond->>\" ~(str expr))\n                (pr-clog ~(str expr) ~expr)\n                (let [~g ~expr\n                      ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n                  ~(when (cljs-env? &env)\n                     `(l/group-end))\n                  ~g)))))\n     (cljs-env? &env) clj->cljs)))\n\n(defn- log-some-step\n  [some-step]\n  `(pr-clog\n    ~(str #_(second some-step)\n      #_\" \"\n      (->> some-step (filter seq?) last last))\n    ~some-step))\n\n(defmacro *some->\n  \"Traced version of some->\"\n  [expr & forms]\n  (let [untraced `(~'some-> ~expr ~@forms)]\n    (cond->\n     (if-not (u/get-env-config)\n       untraced\n       `(if-not ghostwheel.core/*global-trace-allowed?*\n          ~untraced\n          ~(let [g     (gensym)\n                 pstep (fn [step] `(if (nil? ~g) nil (-> ~g ~step)))]\n             `(do\n                (log-threading-header \"some->\" ~(str expr))\n                (pr-clog ~(str expr) ~expr)\n                (let [~g ~expr\n                      ~@(interleave (repeat g) (map log-some-step (map pstep forms)))]\n                  ~(when (cljs-env? &env)\n                     `(l/group-end))\n                  ~g)))))\n     (cljs-env? &env) clj->cljs)))\n\n(defmacro *some->>\n  \"Traced version of some->>\"\n  [expr & forms]\n  (let [untraced `(~'some->> ~expr ~@forms)]\n    (cond->\n     (if-not (u/get-env-config)\n       untraced\n       `(if-not ghostwheel.core/*global-trace-allowed?*\n          ~untraced\n          ~(let [g     (gensym)\n                 pstep (fn [step] `(if (nil? ~g) nil (->> ~g ~step)))]\n             `(do\n                (log-threading-header \"some->>\" ~(str expr))\n                (pr-clog ~(str expr) ~expr)\n                (let [~g ~expr\n                      ~@(interleave (repeat g) (map log-some-step (map pstep forms)))]\n                  ~(when (cljs-env? &env)\n                     `(l/group-end))\n                  ~g)))))\n     (cljs-env? &env) clj->cljs)))\n\n\n"]}